---
title: "Simple back-of-the envelope power calculations"
output:
  rmdformats::robobook:
    code_folding: show
---

```{r}
packages <-
  c(
    "here",
    "tidyverse",
    "assertthat",
    "clusterPower",
    "ICC",
    "kableExtra",
    "haven"
  )

pacman::p_load(
  packages,
  character.only = TRUE,
  dep = TRUE
)
```

# Data 

```{r}
child <-
  read_rds(
    here(
      Sys.getenv("BOX"),
      "i-h20-kswtcs",
      "data",
      "mother-survey",
      "final",
      "child.rds"
    )
  )
```

The data used for these calculation is observed at child level and has been processed and validated. It is the same data set that will be used for ITT analysis.

We have a total of `r nrow(child)` children in our data. The sample for ITT, however, should exclude blocks that did not have at least one control and one treatment cluster as well as children who were not exposed to the intervention.

```{r}
sample <-
  child %>%
  filter(
    exposure != "None", 
    !flag_nocontrol_block,
    !flag_single_cluster_block
  )

nrow(sample)
```
There are a few more children whose age at death is unknown

```{r}
sample <-
  sample %>%
  filter(
    !is.na(dead_u5)
  )

nrow(sample)
```


```{r}
n_children <- 
  sample %>% 
  nrow

n_clusters <- 
  sample %>% 
  pull(clusterid) %>% 
  n_distinct

n_blocks <- 
  sample %>% 
  pull(blockid) %>% 
  n_distinct

cluster_size <- 
  sample %>% 
  group_by(clusterid) %>% 
  summarise(size = n()) %>% 
  pull(size) %>% 
  mean

MR <- mean(sample$dead_u5)
```

We have `r n_children` children, `r n_clusters` clusters, and `r n_blocks` blocks in the ITT sample. Average cluster size is of `r cluster_size %>% round(2)` children. Sample mortality rate is `r (MR * 100) %>% round(2)`%.

# Assumptions

We will use plug-in formulas only, with standard assumptions of 80% power and 5% significance level. Treatment was assigned within blocks at the cluster level, though - i.e. the block id is the variable that was stratified on. Since treatment was assigned at cluster level, we are interested at the cluster size and the ICC at the cluster level.

```{r}
power <- .8
```

The mortality rate used for previous calculations 40/1e3. We are updating these using county-level numbers from 2019:

- Vihiga: 66
- Bungoma: `r er_b = 38; er_b`
- Kakamega: `r er_k = 52; er_b`

We are interested in 2014-2020 averages, so these have to be augmented a bit because of the secular trend of declining mortality. The study areas are in rural parts, so that will increase the mortality a bit again. Vihiga county has `r sample %>% filter(vihiga) %>% pull(clusterid) %>% n_distinct` clusters only, so we will neglect it. We take average over Bungoma and Kakamega counties and augment it by 10% (the nationwide decline from 2012 to 2019 was over 20% - so this is still more on the conservative side).

```{r}
event_rate <- mean(c(er_b, er_k)) * 1.1
```

This gives us an event rate of `r event_rate`, which corresponds to roughly half of the observed child mortality rate (since child is followed for about 2.5 years).

```{r, eval = FALSE}
MR <- event_rate/2/1e3
```

# Calculate ICC

## Using a regression

```{r}
icc_reg <-
  lm(
    dead_u5 ~ clusterid,
    data = child
  )

icc <- summary(icc_reg)$r.squared
```

Unconditional ICC is `r icc`


To calculate the conditional ICC, we first need to regress the outcome on stratum fixed effects and calculate the residual from this regression.

```{r}
block_mortality <-
  lm(
    dead_u5 ~ blockid,
    data = sample
  )

sample <-
  sample %>%
  mutate(
    residual = resid(block_mortality)
  )
```

We then plug the residual instead of the outcome on the ICC calculation.

```{r}
icc_reg <-
  lm(
    residual ~ clusterid,
    data = sample
  )

icc <- summary(icc_reg)$r.squared
```

Conditional ICC is `r icc`

## Using `ICCest`

```{r}
icc_est <-
  ICCest(
    clusterid,
    dead_u5,
    data = sample,
    CI.type = "Smith"
  )

icc_est %>% 
  unlist %>% 
  t %>% 
  kable
```

We will use this value, as it's a more established method. 

```{r}
icc <- icc_est$ICC
```

We could also use the same command plugging in the residual to obtain the conditional ICC.

```{r}
ICCest(
  clusterid,
  residual,
  data = sample,
  CI.type = "Smith"
) %>% 
  unlist %>% 
  t %>%
  kable
```

This is a less established method and the confidence interval includes zero. In fact, the point estimate is negative. So we will not use this for reporting purposes. The main take-away here is that our ICC estimates are very small.

## Check using Stata's `loneway`

Output from `loneway dead_u5 clusterid` is below, and ICC is 0.0011765430462743

```
                   One-way analysis of variance for dead_u5: 

                                             Number of obs =       94,845
                                                 R-squared =       0.0060

    Source                SS         df      MS            F     Prob > F
-------------------------------------------------------------------------
Between clusterid      12.990213    458    .02836291      1.24     0.0003
Within clusterid       2153.1407 94,386    .02281208
-------------------------------------------------------------------------
Total                  2166.1309 94,844    .02283888

         Intraclass       Asy.        
         correlation      S.E.       [95% conf. interval]
         ------------------------------------------------
            0.00118     0.00040       0.00039     0.00196

         Estimated SD of clusterid effect        .0051837
         Estimated SD within clusterid           .1510367
         Est. reliability of a clusterid mean     0.19571
              (evaluated at n=206.57)
```

# MDE calculation

## All children in the sample

```{r}
power.out <- 
  cpa.binary(
    nclusters = n_clusters/2, 
    nsubjects = cluster_size, 
    ICC = icc, 
    p2 = MR, 
    p1inc = FALSE, 
    power = power,
    tol = .Machine$double.eps^.5 
  )
```

**MDE is `r ((MR - power.out) / MR * 1e2) %>% round(2)`%**. This is the main estimate we will report.

## Only children who benefited from treatment

```{r}
power.out <- 
  cpa.binary(
    nclusters = n_clusters/2, 
    nsubjects = cluster_size/4, 
    ICC = icc, 
    p2 = MR, 
    p1inc = FALSE, 
    power = power,
    tol = .Machine$double.eps^.5 
  )
```

MDE is `r (((MR - power.out) / MR * 1e2)/4) %>% round(2)`%
